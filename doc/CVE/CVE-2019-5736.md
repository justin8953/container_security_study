# runC CVE-2019-5736

## 1. CVE Description

Runc through 1.0-rc6, as used in Docker before 18.09.2 and other products, allows attackers to overwrite the host runc binary (and consequently obtain host root access) by leveraging the ability to execute a command as root within one of these types of containers:

1. a new container with an attacker-controlled image
2. an existing container, to which the attacker previously had write access, that can be attached with docker exec.

This occurs because of file-descriptor mishandling, related to /proc/self/exe.

## 2. Concept

### 2.1 What is runC

RunC is a container runtime originally developed as part of Docker and later extracted out as a separate open source tool and library. As a “low level” container runtime, runC is mainly used by “high level” container runtimes (e.g. Docker) to spawn and run containers, although it can be used as a stand-alone tool.
“High level” container runtimes like Docker will normally implement functionalities such as image creation and management and will use runC to handle tasks related to running containers – creating a container, attaching a process to an existing container (docker exec) and so on.

## 2.2. Procfs

The proc filesystem is a virtual filesystem in Linux that presents information primarily about processes, typically mounted to `/proc`. It is virtual in a sense that it does not exist on disk. Instead, the kernel creates it in memory. It can be thought of as an interface to system data that the kernel exposes as a filesystem. Each process has its own directory in procfs, at `/proc/[pid]`:

```bash
ll /proc | sed -n -e 1,9p -e 54p
total 4
dr-xr-xr-x 250 root             root                           0  五  25 14:55 ./
drwxr-xr-x  20 root             root                        4096  五  25 14:33 ../
dr-xr-xr-x   9 root             root                           0  五  25 14:55 1/
dr-xr-xr-x   9 root             root                           0  五  25 14:55 10/
dr-xr-xr-x   9 root             root                           0  五  25 14:55 1023/
dr-xr-xr-x   9 root             root                           0  五  25 14:55 106/
dr-xr-xr-x   9 root             root                           0  五  25 14:55 109/
dr-xr-xr-x   9 root             root                           0  五  25 14:55 1091/
lrwxrwxrwx   1 root             root                           0  五  25 14:55 /proc/self -> 1932/
```

`/proc/self` is a symbolic link to the directory of the currently running process (in this case pid 1932). Each process’s directory contains several files and directories with information on the process. For the vulnerability, the relevant ones are:

- `/proc/self/exe`: a symbolic link to the executable file the process is running.
- `/proc/self/fd`: a directory containing the file descriptors open by the process.

For example, by listing the files under `/proc/self` using `ls /proc/self` one can see that `/proc/self/exe` points to the `ls` executable.

### 2.3 Vulnerability

The vulnerability allows a malicious container to (with minimal user interaction) overwrite the host runc binary and thus gain root-level code execution on the host. The level of user interaction is being able to run any command ... as root within a container in either of these contexts:

1. Creating a new container using an attacker-controlled image.
2. Attaching (docker exec) into an existing container which the attacker had previous write access to.

Those two scenarios might seem different, but both require runC to spin up a new process in a container and are implemented similarly. In both cases, runC is tasked with running a user-defined binary in the container. In Docker, this binary is either the image’s entry point when starting a new container, or docker exec’s argument when attaching to an existing container.

When this user binary is run, it must already be confined and restricted inside the container, or it can jeopardize the host. In order to accomplish that, runC creates a ‘runC init’ subprocess which places all needed restrictions on itself (such as entering or setting up namespaces) and effectively places itself in the container. Then, the runC init process, now in the container, calls the execve syscall to overwrite itself with the user requested binary.

This is the method used by runC both for creating new containers and for attaching a process to an existing container.
![runc_init1](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/runc_init1.jpg)
The researchers who revealed the vulnerability discovered that an attacker can trick runC into executing itself by asking it to run /proc/self/exe, which is a symbolic link to the runC binary on the host.
![runc_init2](https://unit42.paloaltonetworks.com/wp-content/uploads/2019/10/runc_init2.jpg)

An attacker with root access in the container can then use `/proc/[runc-pid]/exe` as a reference to the runC binary on the host and overwrite it. Root access in the container is required to perform this attack as the runC binary is owned by root.
The next time runC is executed, the attacker will achieve code execution on the host. Since runC is normally run as root (e.g. by the Docker daemon), the attacker will gain root access on the host.

## 3 Exploitation

When the user runs something like `docker exec container_name /bin/bash`, the loader will recognize the shebang in the modified bash and execute the interpreter we specified – /proc/self/exe, which is a symlink to the runC binary.
We can proceed to overwrite the runC binary from a separate process in the container through `/proc/[runc-pid]/exe`.

```bash
#!/bin/bash_original
echo "[+] Waiting for runC to be executed in the container..."

runc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')

# Wait for /proc/self/exe to be executed
while [ -z "$runc_pid" ]; do
    runc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')
done

# Call overwrite_runc with the symlink to the runC binary
./overwrite_runc /proc/${runc_pid}/exe
```

Basically, we cannot overwrite the runC binary while a process is running it. On the other hand, if the runC process exits, `/proc/[runc-pid]/exe` will vanish and we will lose the reference to the runC binary. To overcome this, we open `/proc/[runc-pid]/exe` for reading in our process, which creates a file descriptor at `/proc/[our-pid]/fd/3`.
We then wait for the runC process to exit, and proceed to open `/proc/[our-pid]/fd/3` for writing, and overwrite runC.

This method has one setback though – it requires an additional process to run the attacker code. Since containers are started with only one process (i.e. the Docker’s image entry point), this approach couldn’t be used to create a malicious image that will compromise the host when run

## 4. Reference

1.[Breaking out of Docker via runC – Explaining CVE-2019-5736](https://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736/)

2.[RunC-CVE-2019-5736 POC](https://github.com/twistlock/RunC-CVE-2019-5736)